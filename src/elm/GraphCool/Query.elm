-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module GraphCool.Query exposing (..)

import GraphCool.Enum.ChatOrderBy
import GraphCool.Enum.EventOrderBy
import GraphCool.Enum.FileOrderBy
import GraphCool.Enum.HostOrderBy
import GraphCool.Enum.LocationOrderBy
import GraphCool.Enum.MessageOrderBy
import GraphCool.Enum.PoolOrderBy
import GraphCool.Enum.UserOrderBy
import GraphCool.Enum.VenueOrderBy
import GraphCool.InputObject
import GraphCool.Interface
import GraphCool.Object
import GraphCool.Scalar
import GraphCool.Union
import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


{-| Select fields to build up a top-level query. The request can be sent with
functions from `Graphqelm.Http`.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) RootQuery
selection constructor =
    Object.selection constructor


type alias AllChatsOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.ChatFilter, orderBy : OptionalArgument GraphCool.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allChats : (AllChatsOptionalArguments -> AllChatsOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Chat -> Field (List decodesTo) RootQuery
allChats fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allChats" optionalArgs object (identity >> Decode.list)


type alias AllEventsOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.EventFilter, orderBy : OptionalArgument GraphCool.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allEvents : (AllEventsOptionalArguments -> AllEventsOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Event -> Field (List decodesTo) RootQuery
allEvents fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeEventFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.EventOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allEvents" optionalArgs object (identity >> Decode.list)


type alias AllFilesOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.FileFilter, orderBy : OptionalArgument GraphCool.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allFiles : (AllFilesOptionalArguments -> AllFilesOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.File -> Field (List decodesTo) RootQuery
allFiles fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeFileFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.FileOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allFiles" optionalArgs object (identity >> Decode.list)


type alias AllHostsOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.HostFilter, orderBy : OptionalArgument GraphCool.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allHosts : (AllHostsOptionalArguments -> AllHostsOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Host -> Field (List decodesTo) RootQuery
allHosts fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allHosts" optionalArgs object (identity >> Decode.list)


type alias AllLocationsOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.LocationFilter, orderBy : OptionalArgument GraphCool.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allLocations : (AllLocationsOptionalArguments -> AllLocationsOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Location -> Field (List decodesTo) RootQuery
allLocations fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeLocationFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.LocationOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allLocations" optionalArgs object (identity >> Decode.list)


type alias AllMessagesOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.MessageFilter, orderBy : OptionalArgument GraphCool.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allMessages : (AllMessagesOptionalArguments -> AllMessagesOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Message -> Field (List decodesTo) RootQuery
allMessages fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allMessages" optionalArgs object (identity >> Decode.list)


type alias AllPoolsOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.PoolFilter, orderBy : OptionalArgument GraphCool.Enum.PoolOrderBy.PoolOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allPools : (AllPoolsOptionalArguments -> AllPoolsOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Pool -> Field (List decodesTo) RootQuery
allPools fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodePoolFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.PoolOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allPools" optionalArgs object (identity >> Decode.list)


type alias AllUsersOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.UserFilter, orderBy : OptionalArgument GraphCool.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allUsers : (AllUsersOptionalArguments -> AllUsersOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.User -> Field (List decodesTo) RootQuery
allUsers fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allUsers" optionalArgs object (identity >> Decode.list)


type alias AllVenuesOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.VenueFilter, orderBy : OptionalArgument GraphCool.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allVenues : (AllVenuesOptionalArguments -> AllVenuesOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Venue -> Field (List decodesTo) RootQuery
allVenues fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allVenues" optionalArgs object (identity >> Decode.list)


type alias AllChatsMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.ChatFilter, orderBy : OptionalArgument GraphCool.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allChatsMeta_ : (AllChatsMetaOptionalArguments -> AllChatsMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allChatsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allChatsMeta" optionalArgs object identity


type alias AllEventsMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.EventFilter, orderBy : OptionalArgument GraphCool.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allEventsMeta_ : (AllEventsMetaOptionalArguments -> AllEventsMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allEventsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeEventFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.EventOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allEventsMeta" optionalArgs object identity


type alias AllFilesMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.FileFilter, orderBy : OptionalArgument GraphCool.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allFilesMeta_ : (AllFilesMetaOptionalArguments -> AllFilesMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allFilesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeFileFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.FileOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allFilesMeta" optionalArgs object identity


type alias AllHostsMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.HostFilter, orderBy : OptionalArgument GraphCool.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allHostsMeta_ : (AllHostsMetaOptionalArguments -> AllHostsMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allHostsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allHostsMeta" optionalArgs object identity


type alias AllLocationsMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.LocationFilter, orderBy : OptionalArgument GraphCool.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allLocationsMeta_ : (AllLocationsMetaOptionalArguments -> AllLocationsMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allLocationsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeLocationFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.LocationOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allLocationsMeta" optionalArgs object identity


type alias AllMessagesMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.MessageFilter, orderBy : OptionalArgument GraphCool.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allMessagesMeta_ : (AllMessagesMetaOptionalArguments -> AllMessagesMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allMessagesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allMessagesMeta" optionalArgs object identity


type alias AllPoolsMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.PoolFilter, orderBy : OptionalArgument GraphCool.Enum.PoolOrderBy.PoolOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allPoolsMeta_ : (AllPoolsMetaOptionalArguments -> AllPoolsMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allPoolsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodePoolFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.PoolOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allPoolsMeta" optionalArgs object identity


type alias AllUsersMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.UserFilter, orderBy : OptionalArgument GraphCool.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allUsersMeta_ : (AllUsersMetaOptionalArguments -> AllUsersMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allUsersMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allUsersMeta" optionalArgs object identity


type alias AllVenuesMetaOptionalArguments =
    { filter : OptionalArgument GraphCool.InputObject.VenueFilter, orderBy : OptionalArgument GraphCool.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-|

  - filter -

-}
allVenuesMeta_ : (AllVenuesMetaOptionalArguments -> AllVenuesMetaOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.QueryMeta_ -> Field decodesTo RootQuery
allVenuesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter GraphCool.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum GraphCool.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allVenuesMeta" optionalArgs object identity


type alias ChatOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
chat : (ChatOptionalArguments -> ChatOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Chat -> Field (Maybe decodesTo) RootQuery
chat fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Chat" optionalArgs object (identity >> Decode.nullable)


type alias EventOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
event : (EventOptionalArguments -> EventOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Event -> Field (Maybe decodesTo) RootQuery
event fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Event" optionalArgs object (identity >> Decode.nullable)


type alias FileOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id, secret : OptionalArgument String, url : OptionalArgument String }


{-|

  - id -
  - secret -
  - url -

-}
file : (FileOptionalArguments -> FileOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.File -> Field (Maybe decodesTo) RootQuery
file fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, secret = Absent, url = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw), Argument.optional "secret" filledInOptionals.secret Encode.string, Argument.optional "url" filledInOptionals.url Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "File" optionalArgs object (identity >> Decode.nullable)


type alias HostOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
host : (HostOptionalArguments -> HostOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Host -> Field (Maybe decodesTo) RootQuery
host fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Host" optionalArgs object (identity >> Decode.nullable)


type alias LocationOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
location : (LocationOptionalArguments -> LocationOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Location -> Field (Maybe decodesTo) RootQuery
location fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Location" optionalArgs object (identity >> Decode.nullable)


type alias MessageOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
message : (MessageOptionalArguments -> MessageOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Message -> Field (Maybe decodesTo) RootQuery
message fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Message" optionalArgs object (identity >> Decode.nullable)


type alias PoolOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id, seatGeekId : OptionalArgument String }


{-|

  - id -
  - seatGeekId -

-}
pool : (PoolOptionalArguments -> PoolOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Pool -> Field (Maybe decodesTo) RootQuery
pool fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, seatGeekId = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw), Argument.optional "seatGeekId" filledInOptionals.seatGeekId Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "Pool" optionalArgs object (identity >> Decode.nullable)


type alias UserOptionalArguments =
    { auth0UserId : OptionalArgument String, email : OptionalArgument String, id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - auth0UserId -
  - email -
  - id -

-}
user : (UserOptionalArguments -> UserOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.User -> Field (Maybe decodesTo) RootQuery
user fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { auth0UserId = Absent, email = Absent, id = Absent }

        optionalArgs =
            [ Argument.optional "auth0UserId" filledInOptionals.auth0UserId Encode.string, Argument.optional "email" filledInOptionals.email Encode.string, Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "User" optionalArgs object (identity >> Decode.nullable)


type alias VenueOptionalArguments =
    { id : OptionalArgument GraphCool.Scalar.Id }


{-|

  - id -

-}
venue : (VenueOptionalArguments -> VenueOptionalArguments) -> SelectionSet decodesTo GraphCool.Object.Venue -> Field (Maybe decodesTo) RootQuery
venue fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Venue" optionalArgs object (identity >> Decode.nullable)


me : SelectionSet decodesTo GraphCool.Object.User -> Field (Maybe decodesTo) RootQuery
me object =
    Object.selectionField "user" [] object (identity >> Decode.nullable)


type alias NodeRequiredArguments =
    { id : GraphCool.Scalar.Id }


{-| Fetches an object given its ID

  - id - The ID of an object

-}
node : NodeRequiredArguments -> SelectionSet decodesTo GraphCool.Interface.Node -> Field (Maybe decodesTo) RootQuery
node requiredArgs object =
    Object.selectionField "node" [ Argument.required "id" requiredArgs.id (\(GraphCool.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.nullable)
