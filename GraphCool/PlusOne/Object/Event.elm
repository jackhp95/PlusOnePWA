-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module PlusOne.Object.Event exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import PlusOne.Enum.ChatOrderBy
import PlusOne.Enum.HostOrderBy
import PlusOne.Enum.UserOrderBy
import PlusOne.Enum.VenueOrderBy
import PlusOne.InputObject
import PlusOne.Interface
import PlusOne.Object
import PlusOne.Scalar
import PlusOne.Union


{-| Select fields to build up a SelectionSet for this object.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) PlusOne.Object.Event
selection constructor =
    Object.selection constructor


{-|

  - filter -

-}
chats : ({ filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Chat -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
chats fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "chats" optionalArgs object (identity >> Decode.list >> Decode.maybe)


createdAt : Field PlusOne.Scalar.DateTime PlusOne.Object.Event
createdAt =
    Object.fieldDecoder "createdAt" [] (Decode.string |> Decode.map PlusOne.Scalar.DateTime)


{-|

  - filter -

-}
createdBy : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field decodesTo PlusOne.Object.Event
createdBy fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "createdBy" optionalArgs object identity


endsAt : Field (Maybe PlusOne.Scalar.DateTime) PlusOne.Object.Event
endsAt =
    Object.fieldDecoder "endsAt" [] (Decode.string |> Decode.map PlusOne.Scalar.DateTime |> Decode.maybe)


{-|

  - filter -

-}
hosts : ({ filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Host -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
hosts fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "hosts" optionalArgs object (identity >> Decode.list >> Decode.maybe)


id : Field PlusOne.Scalar.Id PlusOne.Object.Event
id =
    Object.fieldDecoder "id" [] (Decode.string |> Decode.map PlusOne.Scalar.Id)


name : Field String PlusOne.Object.Event
name =
    Object.fieldDecoder "name" [] Decode.string


nameFull : Field (Maybe String) PlusOne.Object.Event
nameFull =
    Object.fieldDecoder "nameFull" [] (Decode.string |> Decode.maybe)


private : Field Bool PlusOne.Object.Event
private =
    Object.fieldDecoder "private" [] Decode.bool


startsAt : Field PlusOne.Scalar.DateTime PlusOne.Object.Event
startsAt =
    Object.fieldDecoder "startsAt" [] (Decode.string |> Decode.map PlusOne.Scalar.DateTime)


{-|

  - filter -

-}
usersAttending : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
usersAttending fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "usersAttending" optionalArgs object (identity >> Decode.list >> Decode.maybe)


{-|

  - filter -

-}
usersLiked : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
usersLiked fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "usersLiked" optionalArgs object (identity >> Decode.list >> Decode.maybe)


{-|

  - filter -

-}
usersViewed : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
usersViewed fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "usersViewed" optionalArgs object (identity >> Decode.list >> Decode.maybe)


{-|

  - filter -

-}
venues : ({ filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Venue -> Field (Maybe (List decodesTo)) PlusOne.Object.Event
venues fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "venues" optionalArgs object (identity >> Decode.list >> Decode.maybe)


{-| Meta information about the query.

  - filter -

-}
chatsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
chatsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_chatsMeta" optionalArgs object identity


{-| Meta information about the query.

  - filter -

-}
hostsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
hostsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_hostsMeta" optionalArgs object identity


{-| Meta information about the query.

  - filter -

-}
usersAttendingMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
usersAttendingMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_usersAttendingMeta" optionalArgs object identity


{-| Meta information about the query.

  - filter -

-}
usersLikedMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
usersLikedMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_usersLikedMeta" optionalArgs object identity


{-| Meta information about the query.

  - filter -

-}
usersViewedMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
usersViewedMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_usersViewedMeta" optionalArgs object identity


{-| Meta information about the query.

  - filter -

-}
venuesMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Event
venuesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_venuesMeta" optionalArgs object identity
