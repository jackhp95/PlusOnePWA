-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module PlusOne.Object.Chat exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import PlusOne.Enum.DateState
import PlusOne.Enum.MessageOrderBy
import PlusOne.InputObject
import PlusOne.Interface
import PlusOne.Object
import PlusOne.Scalar
import PlusOne.Union


{-| Select fields to build up a SelectionSet for this object.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) PlusOne.Object.Chat
selection constructor =
    Object.selection constructor


{-|

  - filter -

-}
canceled : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) PlusOne.Object.Chat
canceled fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "canceled" optionalArgs object (identity >> Decode.maybe)


dateState : Field PlusOne.Enum.DateState.DateState PlusOne.Object.Chat
dateState =
    Object.fieldDecoder "dateState" [] PlusOne.Enum.DateState.decoder


{-|

  - filter -

-}
event : ({ filter : OptionalArgument PlusOne.InputObject.EventFilter } -> { filter : OptionalArgument PlusOne.InputObject.EventFilter }) -> SelectionSet decodesTo PlusOne.Object.Event -> Field decodesTo PlusOne.Object.Chat
event fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeEventFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "event" optionalArgs object identity


id : Field PlusOne.Scalar.Id PlusOne.Object.Chat
id =
    Object.fieldDecoder "id" [] (Decode.string |> Decode.map PlusOne.Scalar.Id)


{-|

  - filter -

-}
initiated : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field decodesTo PlusOne.Object.Chat
initiated fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "initiated" optionalArgs object identity


{-|

  - filter -

-}
messages : ({ filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Message -> Field (Maybe (List decodesTo)) PlusOne.Object.Chat
messages fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "messages" optionalArgs object (identity >> Decode.list >> Decode.maybe)


{-|

  - filter -

-}
passed : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) PlusOne.Object.Chat
passed fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "passed" optionalArgs object (identity >> Decode.maybe)


{-|

  - filter -

-}
proposed : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) PlusOne.Object.Chat
proposed fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "proposed" optionalArgs object (identity >> Decode.maybe)


{-|

  - filter -

-}
recipient : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) PlusOne.Object.Chat
recipient fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter ]
                |> List.filterMap identity
    in
    Object.selectionField "recipient" optionalArgs object (identity >> Decode.maybe)


{-| Meta information about the query.

  - filter -

-}
messagesMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo PlusOne.Object.Chat
messagesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_messagesMeta" optionalArgs object identity
