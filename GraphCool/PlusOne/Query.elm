-- Do not manually edit this file, it was auto-generated by Graphqelm
-- https://github.com/dillonkearns/graphqelm


module PlusOne.Query exposing (..)

import Graphqelm.Field as Field exposing (Field)
import Graphqelm.Internal.Builder.Argument as Argument exposing (Argument)
import Graphqelm.Internal.Builder.Object as Object
import Graphqelm.Internal.Encode as Encode exposing (Value)
import Graphqelm.Operation exposing (RootQuery)
import Graphqelm.OptionalArgument exposing (OptionalArgument(Absent))
import Graphqelm.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import PlusOne.Enum.ChatOrderBy
import PlusOne.Enum.EventOrderBy
import PlusOne.Enum.FileOrderBy
import PlusOne.Enum.HostOrderBy
import PlusOne.Enum.LocationOrderBy
import PlusOne.Enum.MessageOrderBy
import PlusOne.Enum.UserOrderBy
import PlusOne.Enum.VenueOrderBy
import PlusOne.InputObject
import PlusOne.Interface
import PlusOne.Object
import PlusOne.Scalar
import PlusOne.Union


{-| Select fields to build up a top-level query. The request can be sent with
functions from `Graphqelm.Http`.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) RootQuery
selection constructor =
    Object.selection constructor


{-|

  - filter -

-}
allChats : ({ filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Chat -> Field (List decodesTo) RootQuery
allChats fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allChats" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allEvents : ({ filter : OptionalArgument PlusOne.InputObject.EventFilter, orderBy : OptionalArgument PlusOne.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.EventFilter, orderBy : OptionalArgument PlusOne.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Event -> Field (List decodesTo) RootQuery
allEvents fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeEventFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.EventOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allEvents" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allFiles : ({ filter : OptionalArgument PlusOne.InputObject.FileFilter, orderBy : OptionalArgument PlusOne.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.FileFilter, orderBy : OptionalArgument PlusOne.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.File -> Field (List decodesTo) RootQuery
allFiles fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeFileFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.FileOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allFiles" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allHosts : ({ filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Host -> Field (List decodesTo) RootQuery
allHosts fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allHosts" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allLocations : ({ filter : OptionalArgument PlusOne.InputObject.LocationFilter, orderBy : OptionalArgument PlusOne.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.LocationFilter, orderBy : OptionalArgument PlusOne.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Location -> Field (List decodesTo) RootQuery
allLocations fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeLocationFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.LocationOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allLocations" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allMessages : ({ filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Message -> Field (List decodesTo) RootQuery
allMessages fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allMessages" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allUsers : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (List decodesTo) RootQuery
allUsers fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allUsers" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allVenues : ({ filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.Venue -> Field (List decodesTo) RootQuery
allVenues fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "allVenues" optionalArgs object (identity >> Decode.list)


{-|

  - filter -

-}
allChatsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.ChatFilter, orderBy : OptionalArgument PlusOne.Enum.ChatOrderBy.ChatOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allChatsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeChatFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.ChatOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allChatsMeta" optionalArgs object identity


{-|

  - filter -

-}
allEventsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.EventFilter, orderBy : OptionalArgument PlusOne.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.EventFilter, orderBy : OptionalArgument PlusOne.Enum.EventOrderBy.EventOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allEventsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeEventFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.EventOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allEventsMeta" optionalArgs object identity


{-|

  - filter -

-}
allFilesMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.FileFilter, orderBy : OptionalArgument PlusOne.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.FileFilter, orderBy : OptionalArgument PlusOne.Enum.FileOrderBy.FileOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allFilesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeFileFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.FileOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allFilesMeta" optionalArgs object identity


{-|

  - filter -

-}
allHostsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.HostFilter, orderBy : OptionalArgument PlusOne.Enum.HostOrderBy.HostOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allHostsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeHostFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.HostOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allHostsMeta" optionalArgs object identity


{-|

  - filter -

-}
allLocationsMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.LocationFilter, orderBy : OptionalArgument PlusOne.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.LocationFilter, orderBy : OptionalArgument PlusOne.Enum.LocationOrderBy.LocationOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allLocationsMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeLocationFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.LocationOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allLocationsMeta" optionalArgs object identity


{-|

  - filter -

-}
allMessagesMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.MessageFilter, orderBy : OptionalArgument PlusOne.Enum.MessageOrderBy.MessageOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allMessagesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeMessageFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.MessageOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allMessagesMeta" optionalArgs object identity


{-|

  - filter -

-}
allUsersMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.UserFilter, orderBy : OptionalArgument PlusOne.Enum.UserOrderBy.UserOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allUsersMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeUserFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.UserOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allUsersMeta" optionalArgs object identity


{-|

  - filter -

-}
allVenuesMeta_ : ({ filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int } -> { filter : OptionalArgument PlusOne.InputObject.VenueFilter, orderBy : OptionalArgument PlusOne.Enum.VenueOrderBy.VenueOrderBy, skip : OptionalArgument Int, after : OptionalArgument String, before : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }) -> SelectionSet decodesTo PlusOne.Object.QueryMeta_ -> Field decodesTo RootQuery
allVenuesMeta_ fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { filter = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "filter" filledInOptionals.filter PlusOne.InputObject.encodeVenueFilter, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum PlusOne.Enum.VenueOrderBy.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "_allVenuesMeta" optionalArgs object identity


{-|

  - id -

-}
chat : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Chat -> Field (Maybe decodesTo) RootQuery
chat fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Chat" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -

-}
event : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Event -> Field (Maybe decodesTo) RootQuery
event fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Event" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -
  - secret -
  - url -

-}
file : ({ id : OptionalArgument PlusOne.Scalar.Id, secret : OptionalArgument String, url : OptionalArgument String } -> { id : OptionalArgument PlusOne.Scalar.Id, secret : OptionalArgument String, url : OptionalArgument String }) -> SelectionSet decodesTo PlusOne.Object.File -> Field (Maybe decodesTo) RootQuery
file fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent, secret = Absent, url = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw), Argument.optional "secret" filledInOptionals.secret Encode.string, Argument.optional "url" filledInOptionals.url Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "File" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -

-}
host : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Host -> Field (Maybe decodesTo) RootQuery
host fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Host" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -

-}
location : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Location -> Field (Maybe decodesTo) RootQuery
location fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Location" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -

-}
message : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Message -> Field (Maybe decodesTo) RootQuery
message fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Message" optionalArgs object (identity >> Decode.maybe)


{-|

  - auth0UserId -
  - email -
  - id -

-}
user : ({ auth0UserId : OptionalArgument String, email : OptionalArgument String, id : OptionalArgument PlusOne.Scalar.Id } -> { auth0UserId : OptionalArgument String, email : OptionalArgument String, id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) RootQuery
user fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { auth0UserId = Absent, email = Absent, id = Absent }

        optionalArgs =
            [ Argument.optional "auth0UserId" filledInOptionals.auth0UserId Encode.string, Argument.optional "email" filledInOptionals.email Encode.string, Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "User" optionalArgs object (identity >> Decode.maybe)


{-|

  - id -

-}
venue : ({ id : OptionalArgument PlusOne.Scalar.Id } -> { id : OptionalArgument PlusOne.Scalar.Id }) -> SelectionSet decodesTo PlusOne.Object.Venue -> Field (Maybe decodesTo) RootQuery
venue fillInOptionals object =
    let
        filledInOptionals =
            fillInOptionals { id = Absent }

        optionalArgs =
            [ Argument.optional "id" filledInOptionals.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ]
                |> List.filterMap identity
    in
    Object.selectionField "Venue" optionalArgs object (identity >> Decode.maybe)


user : SelectionSet decodesTo PlusOne.Object.User -> Field (Maybe decodesTo) RootQuery
user object =
    Object.selectionField "user" [] object (identity >> Decode.maybe)


{-| Fetches an object given its ID

  - id - The ID of an object

-}
node : { id : PlusOne.Scalar.Id } -> SelectionSet decodesTo PlusOne.Interface.Node -> Field (Maybe decodesTo) RootQuery
node requiredArgs object =
    Object.selectionField "node" [ Argument.required "id" requiredArgs.id (\(PlusOne.Scalar.Id raw) -> Encode.string raw) ] object (identity >> Decode.maybe)
